name: "Deploy to Deno"
description:
  "Checks out the repository and publishes or deletes the project on Deno Deploy.
  If generateEnv is true, they will get published with the deployment environment as well."
inputs:
  action:
    description: "Action to perform: 'deploy' or 'delete' the project."
    required: true
    default: "deploy"
  token:
    description: "Deno token for publishing."
    required: true
  organization:
    description: The organization to target when deploying the project. If omitted, will default to the user account.
    required: false
  production:
    description: "Deploy to production (uses --prod flag)"
    required: false
    default: "true"
  entrypoint:
    description: "The entrypoint to the script that will be deployed."
    required: false
    default: "src/deno.ts"
  generateEnv:
    description: "Generates the .env file based on the current environment if true."
    required: false
    default: "true"
  project_name:
    description: "Overrides the auto-generated Deno Deploy project name."
    required: false
  envVars:
    description: "Whitespace-separated list of environment variables to include in the generated env-vars file."
    required: false
    default: "KERNEL_PUBLIC_KEY SUPABASE_KEY SUPABASE_URL APP_ID APP_PRIVATE_KEY LOG_LEVEL"
outputs: {}
runs:
  using: "composite"
  steps:
    - name: Setup Deno
      uses: denoland/setup-deno@v2
      with:
        deno-version: v2.x

    - name: Prepare Environment Variables
      shell: bash
      run: |
        if [ -n "${{ inputs.project_name }}" ]; then
          new_name="${{ inputs.project_name }}"
        else
          # Sanitize both project name and branch name to meet Deno Deploy requirements
          project_name=$(echo "${{ github.event.repository.name }}" | sed 's#[^a-zA-Z0-9]#-#g')
          branch_name=$(echo '${{ github.event.ref || github.event.workflow_run.head_branch || github.ref }}' | sed 's#refs/heads/##' | sed 's#[^a-zA-Z0-9]#-#g')
          new_name="${project_name}-${branch_name}"
        fi

        # Clean up the name to meet Deno Deploy requirements:
        # - Only a-z, 0-9, and - allowed
        # - Must not start or end with hyphen
        # - Cannot exceed 26 characters
        new_name=$(echo "$new_name" | sed 's#[^a-zA-Z0-9-]#-#g' | sed 's#^-*##' | sed 's#-*$##' | cut -c 1-26)

        # Ensure we don't end with a hyphen after truncation
        new_name=$(echo "$new_name" | sed 's#-*$##')

        # Ensure minimum length of 3 characters
        if [ ${#new_name} -lt 3 ]; then
          new_name="${new_name}app"
        fi

        echo "DENO_PROJECT_NAME=$new_name" >> $GITHUB_ENV
        DENO_DEPLOYMENT_ID=${{ github.sha }}
        echo "DENO_DEPLOYMENT_ID=$DENO_DEPLOYMENT_ID" >> $GITHUB_ENV
        DENO_ORG="$(echo "${{ inputs.organization != '' && inputs.organization || github.repository_owner }}" | tr '[:upper:]' '[:lower:]')"
        DENO_PROJECT_NAME=${{ inputs.organization }}
        if [ -z "$DENO_PROJECT_NAME" ]; then
          DENO_PROJECT_NAME=${GITHUB_REPOSITORY#*/}
        fi
        echo "DENO_ORG=$DENO_ORG" >> $GITHUB_ENV
        echo "DENO_PROJECT_NAME=$DENO_PROJECT_NAME" >> $GITHUB_ENV

    # === DEPLOY STEPS ===
    - name: Generate env vars file
      if: inputs.action == 'deploy' && inputs.generateEnv == 'true'
      shell: bash
      run: |
        env_list="${{ inputs.envVars }}"

        cat > generate-env.ts <<'EOF'
        const defaults = [
          "KERNEL_PUBLIC_KEY",
          "SUPABASE_KEY",
          "SUPABASE_URL",
          "APP_ID",
          "APP_PRIVATE_KEY",
          "LOG_LEVEL",
        ];

        const allow = Array.from(
          new Set([
            ...defaults,
            ...(Deno.env.get("ENV_VARS") ?? "")
              .split(/\s+/)
              .map((s) => s.trim())
              .filter(Boolean),
          ]),
        );

        if (allow.length === 0) {
          console.log("No env vars specified; skipping env-vars.json generation.");
          Deno.exit(0);
        }

        const toBase64 = (value: string) => {
          const bytes = new TextEncoder().encode(value);
          let binary = "";
          for (const b of bytes) binary += String.fromCharCode(b);
          return btoa(binary);
        };

        const envVars = Deno.env.toObject();
        const entries = allow
          .map((k) => ({ key: k, value: envVars[k] }))
          .filter(({ value }) => value !== undefined && value !== null && `${value}`.trim() !== "")
          .map(({ key, value }) => ({ key, value: toBase64(String(value)) }));

        if (entries.length === 0) {
          console.log("No matching env vars found; skipping env-vars.json generation.");
          Deno.exit(0);
        }

        await Deno.writeTextFile("env-vars.json", JSON.stringify(entries));
        EOF
        ENV_VARS="$env_list" deno run --allow-env --allow-write=env-vars.json generate-env.ts
        rm generate-env.ts

    - name: Create deno.jsonc
      shell: bash
      run: |
        cat > deno.jsonc <<EOF
        {
          "deploy": {
            "org": "${DENO_ORG}",
            "app": "${DENO_PROJECT_NAME}"
          }
        }
        EOF

    - name: Manage Deno Deploy Project (Deploy)
      if: inputs.action == 'deploy'
      shell: bash
      id: deno_project
      env:
        DENO_DEPLOY_TOKEN: ${{ inputs.token }}
      run: |
        deno deploy --token $DENO_DEPLOY_TOKEN --org $DENO_ORG --app $DENO_PROJECT_NAME || true

    - name: Update manifest.json with deployment URL
      if: inputs.action == 'deploy'
      uses: actions/github-script@v7
      with:
        script: |
          const fs = require('fs');
          const path = require('path');

          const manifestPath = path.resolve("${{ github.workspace }}", './manifest.json');

          if (!fs.existsSync(manifestPath)) {
            console.log('manifest.json not found. Skipping update.');
            return;
          }

          const manifest = JSON.parse(fs.readFileSync(manifestPath, 'utf8'));

          manifest["homepage_url"] = "${{ steps.deno_project.outputs.deployment_url }}";

          const updatedManifest = JSON.stringify(manifest, null, 2);
          fs.writeFileSync(manifestPath, updatedManifest);
          console.log('Updated manifest:', updatedManifest);

    - name: Deploy to Deno
      if: inputs.action == 'deploy'
      shell: bash
      env:
        DENO_DEPLOY_TOKEN: ${{ inputs.token }}
      run: |
        echo "Will use the following deno.jsonc:"
        cat deno.jsonc
        echo "env-vars.json present: $(test -f env-vars.json && echo 'yes' || echo 'no')"
        contexts=$([ "${{ inputs.production }}" = "true" ] && echo "Production" || echo "Preview")

        if [ ! -f env-vars.json ]; then
          echo "No env-vars.json found; skipping env sync."
          exit 0
        fi

        cat > sync-env.ts <<'EOF'
        const contexts = (Deno.env.get("CONTEXTS") ?? "")
          .split(/\s+/)
          .map((v) => v.trim())
          .filter(Boolean);

        const token = Deno.env.get("DENO_DEPLOY_TOKEN") ?? "";
        if (!token) {
          console.error("Missing DENO_DEPLOY_TOKEN");
          Deno.exit(1);
        }

        const decode = (value: string) => {
          const binary = atob(value);
          const bytes = new Uint8Array(binary.length);
          for (let i = 0; i < binary.length; i += 1) bytes[i] = binary.charCodeAt(i);
          return new TextDecoder().decode(bytes);
        };

        const run = async (args: string[]) => {
          const cmd = new Deno.Command("deno", { args, stdout: "piped", stderr: "piped" });
          const result = await cmd.output();
          const stdout = new TextDecoder().decode(result.stdout).trim();
          const stderr = new TextDecoder().decode(result.stderr).trim();
          if (stdout) console.log(stdout);
          if (result.code !== 0) {
            if (stderr) console.error(stderr);
            Deno.exit(result.code);
          }
        };

        const data = JSON.parse(await Deno.readTextFile("env-vars.json")) as { key: string; value: string }[];

        for (const { key, value } of data) {
          if (!key || !value) continue;
          const decoded = decode(value);
          await run(["deploy", "env", "delete", key, "--token", token]);
          await run(["deploy", "env", "add", key, decoded, "--token", token]);
          if (contexts.length) await run(["deploy", "env", "update-contexts", key, ...contexts, "--token", token]);
        }
        EOF

        CONTEXTS="$contexts" DENO_DEPLOY_TOKEN="$DENO_DEPLOY_TOKEN" deno run --allow-all sync-env.ts
        rm -f sync-env.ts

    - name: Get GitHub App token
      if: inputs.action == 'deploy' && env.APP_ID != '' && env.APP_PRIVATE_KEY != ''
      uses: actions/create-github-app-token@v1
      id: app-token
      with:
        app-id: ${{ env.APP_ID }}
        private-key: ${{ env.APP_PRIVATE_KEY }}

    - name: Check if manifest.json exists
      id: check_manifest
      shell: bash
      run: |
        if [ -f manifest.json ]; then
          echo "exists=true" >> $GITHUB_OUTPUT
        else
          echo "exists=false" >> $GITHUB_OUTPUT
        fi

    - name: Format manifest using Prettier
      shell: bash
      if: inputs.action == 'deploy' && steps.check_manifest.outputs.exists == 'true'
      continue-on-error: true
      run: |
        npx prettier --write manifest.json

    - name: Commit file
      if: inputs.action == 'deploy' && steps.check_manifest.outputs.exists == 'true'
      uses: swinton/commit@v2.x
      env:
        GH_TOKEN: ${{ steps.app-token.outputs.token || env.GITHUB_TOKEN }}
      with:
        files: |
          manifest.json
        commit-message: "chore: [skip ci] update manifest.json url"
        ref: ${{ github.event.workflow_run.head_branch || github.ref }}

    - name: Write Deployment URL to Summary
      if: inputs.action == 'deploy'
      shell: bash
      run: |
        echo "### Deployment URL" >> $GITHUB_STEP_SUMMARY
        echo "${{ steps.deno_project.outputs.deployment_url }}" >> $GITHUB_STEP_SUMMARY

    # === DELETE STEP ===

#    - name: Delete Deno Deploy Project
#      if: inputs.action == 'delete'
#      shell: bash
#      env:
#        DENO_DEPLOY_TOKEN: ${{ inputs.token }}
#      run: |
#        deployctl projects delete \
#          --token=$DENO_DEPLOY_TOKEN \
#          --project=$DENO_PROJECT_NAME \
#          --force \
#          --color=never || true
#
#    - name: Write Deletion to Summary
#      if: inputs.action == 'delete'
#      shell: bash
#      run: |
#        echo "### Deployment URL" >> $GITHUB_STEP_SUMMARY
#        echo "Deployment \`${DENO_PROJECT_NAME}\` has been deleted." >> $GITHUB_STEP_SUMMARY
